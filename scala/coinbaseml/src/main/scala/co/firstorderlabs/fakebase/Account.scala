package co.firstorderlabs.fakebase

import java.util.UUID

import co.firstorderlabs.fakebase.currency.Configs.ProductPrice
import co.firstorderlabs.fakebase.currency.Configs.ProductPrice.{ProductVolume, QuoteVolume}
import co.firstorderlabs.fakebase.currency.Volume.{Volume, VolumeCompanion}
import co.firstorderlabs.fakebase.protos.fakebase._
import co.firstorderlabs.fakebase.types.Events._
import co.firstorderlabs.fakebase.types.Types.{Currency, OrderId, OrderRequestId, TimeInterval}
import io.grpc.Status

import scala.collection.mutable.{HashMap, ListBuffer}
import scala.concurrent.Future

object Account {
  case class Wallet[A <: Volume[A]](currency: Currency,
                                    initialBalance: A,
                                    walletId: String) {
    var balance = initialBalance
    var holds = initialBalance.companion.zeroVolume

    def setHolds(volume: A): Unit = {
      holds = volume
    }
  }

  // This type was autogenerated by intellij. I don't fully understand it, but it works.
  type WalletMap = HashMap[Currency, Wallet[_ >: ProductVolume with QuoteVolume <: Volume[_ >: ProductVolume with QuoteVolume]]]

  case class WalletsCheckpoint(walletsMap: WalletMap) extends Checkpoint

  object Wallets extends Checkpointable[WalletsCheckpoint] {
    private val walletsMap: WalletMap = new HashMap

    def addFunds[A <: Volume[A]](volume: A): Unit = {
      getWallet(volume.companion).balance += volume
    }

    def calcRequiredBuyHold(order: BuyOrderEvent): QuoteVolume = {
      order match {
        case order: BuyLimitOrder  => order.price * order.size
        case order: BuyMarketOrder => order.funds
      }
    }

    def checkpoint: WalletsCheckpoint = WalletsCheckpoint(walletsMap.clone)

    def clear: Unit = walletsMap.clear

    def getAvailableFunds[A <: Volume[A]](
      volume: VolumeCompanion[A]
    ): Volume[A] = {
      val wallet = getWallet(volume)
      wallet.balance - wallet.holds
    }

    def incrementHolds(order: OrderEvent): Unit = {
      order match {
        case order: BuyOrderEvent => {
          val wallet = getWallet(QuoteVolume)
          val orderHolds = Wallets.calcRequiredBuyHold(order)
          val newHolds = wallet.holds + orderHolds
          wallet.setHolds(newHolds)
          order.holds = orderHolds
        }
        case order: SellOrderEvent => {
          val wallet = getWallet(ProductVolume)
          val newHolds = wallet.holds + order.size
          wallet.setHolds(newHolds)
          order.holds = order.size
        }
      }
    }

    def initializeWallets: Unit = {
      walletsMap(ProductVolume.currency) = Wallet(
        ProductVolume.currency,
        new ProductVolume(Right("0.0")),
        UUID.randomUUID().toString
      )
      walletsMap(QuoteVolume.currency) = Wallet(
        QuoteVolume.currency,
        new QuoteVolume(Right("0.0")),
        UUID.randomUUID().toString
      )
    }

    def updateBalances(matchEvent: Match): Unit = {
      val productWallet = getWallet(ProductVolume)
      val quoteWallet = getWallet(QuoteVolume)
      matchEvent.getAccountOrder.get match {
        case _:BuyOrderEvent => {
          productWallet.balance = productWallet.balance + matchEvent.size
          quoteWallet.balance = quoteWallet.balance - matchEvent.price * matchEvent.size + matchEvent.fee
        }
        case _:SellOrderEvent => {
          productWallet.balance = productWallet.balance - matchEvent.size
          quoteWallet.balance = quoteWallet.balance + matchEvent.price * matchEvent.size - matchEvent.fee
        }
      }
    }

    def getWallet[A <: Volume[A]](volume: VolumeCompanion[A]): Wallet[A] = {
      walletsMap(volume.currency).asInstanceOf[Wallet[A]]
    }

    def removeHolds(order: OrderEvent) = {
      order match {
        case order: BuyOrderEvent => {
          val wallet = getWallet(QuoteVolume)
          val newHolds = wallet.holds - order.holds
          wallet.setHolds(newHolds)
          order.holds = QuoteVolume.zeroVolume
        }
        case order: SellOrderEvent => {
          val wallet = getWallet(ProductVolume)
          val newHolds = wallet.holds - order.holds
          wallet.setHolds(newHolds)
          order.holds = ProductVolume.zeroVolume
        }
      }
    }

    def restore(checkpoint: WalletsCheckpoint): Unit = {
      clear
      walletsMap.addAll(checkpoint.walletsMap.iterator)
    }
  }

  class CancellationsHashMap extends HashMap[TimeInterval, ListBuffer[Cancellation]] {
    override def clone: CancellationsHashMap = {
      val clonedMap = new CancellationsHashMap
      clonedMap.addAll(super.clone.iterator)
    }
    override def default(key: TimeInterval) = new ListBuffer[Cancellation]
  }

  class MatchesHashMap extends HashMap[TimeInterval, ListBuffer[Match]] {
    override def clone: MatchesHashMap = {
      val clonedMap = new MatchesHashMap
      clonedMap.addAll(super.clone.iterator)
    }

    override def default(key: TimeInterval) = new ListBuffer[Match]
  }

  case class AccountCheckpoint(orderRequests: HashMap[OrderRequestId, OrderRequest],
                               placedCancellations: CancellationsHashMap,
                               placedOrders: HashMap[OrderId, OrderEvent],
                               matches: MatchesHashMap,
                               walletsCheckpoint: WalletsCheckpoint) extends Checkpoint

  object Account extends AccountServiceGrpc.AccountService with Checkpointable[AccountCheckpoint] {
    private val orderRequests = new HashMap[OrderRequestId, OrderRequest]
    private val placedCancellations = new CancellationsHashMap
    private val placedOrders = new HashMap[OrderId, OrderEvent]
    private val matches = new MatchesHashMap

    def addFunds[A <: Volume[A]](volume: A): Unit = {
      Wallets.addFunds(volume)
    }

    def belongsToAccount(order: OrderEvent): Boolean = {
      placedOrders.contains(order.orderId)
    }

    def checkpoint: AccountCheckpoint = AccountCheckpoint(
      orderRequests.clone,
      placedCancellations.clone,
      placedOrders.clone,
      matches.clone,
      Wallets.checkpoint)

    def clear: Unit = {
      orderRequests.clear
      placedCancellations.clear
      placedOrders.clear
      matches.clear
      Wallets.clear
    }

    def closeOrder[A <: OrderEvent](order: A, doneReason: DoneReason): Option[A] = {
      if (placedOrders.contains(order.orderId))
        if (!List(OrderStatus.received, OrderStatus.open).contains(
              order.orderStatus
            )) return None

        Wallets.removeHolds(order)
        val updatedOrder = OrderUtils.setOrderStatusToDone(order, doneReason)
        placedOrders.update(updatedOrder.orderId, updatedOrder)
        Some(updatedOrder)
    }

    def openOrder(orderId: OrderId): Option[LimitOrderEvent] = {
      val order = placedOrders.get(orderId)
      order match {
        case Some(order) => {
          order match {
            case order: LimitOrderEvent => {
              val updatedOrder = OrderUtils.openOrder(order)
              placedOrders.update(orderId, updatedOrder)
              Some(updatedOrder)
            }
            case _ => None
          }
        }
        case None => None
      }
    }

    def getOrderRequest[A <: OrderRequest](orderRequestId: OrderRequestId): Option[A] = {
      if (orderRequests.contains(orderRequestId))
        Some(orderRequests.get(orderRequestId).asInstanceOf[A])
      else
        None
    }

    def getReceivedCancellations: Iterable[Cancellation] = {
      for (cancellation <- placedCancellations(Exchange.simulationMetadata.get.currentTimeInterval))
        yield cancellation
    }

    def getReceivedOrders: Iterable[OrderEvent] = {
      for (order <- placedOrders.values
           if order.orderStatus == OrderStatus.received)
        yield order
    }

    def hasSufficientFunds(order: BuyOrderEvent): Boolean = {
      val requiredBuyHold = Wallets.calcRequiredBuyHold(order)
      requiredBuyHold > Wallets.getAvailableFunds(QuoteVolume)
    }

    def hasSufficientSize(order: SpecifiesSize): Boolean = {
      val productFunds = Wallets.getAvailableFunds(ProductVolume)
      order.size > productFunds
    }

    def initializeWallets: Unit = Wallets.initializeWallets

    def processMatch(matchEvent: Match) = {
      matches(Exchange.simulationMetadata.get.currentTimeInterval) += matchEvent
      Wallets.updateBalances(matchEvent)
    }

    def restore(checkpoint: AccountCheckpoint): Unit = {
      clear
      orderRequests.addAll(checkpoint.orderRequests.iterator)
      placedCancellations.addAll(checkpoint.placedCancellations.iterator)
      placedOrders.addAll(checkpoint.placedOrders.iterator)
      matches.addAll(checkpoint.matches.iterator)
      Wallets.restore(checkpoint.walletsCheckpoint)
    }

    override def cancelOrder(cancellationRequest: CancellationRequest): Future[Cancellation] = {
      val order = placedOrders.get(cancellationRequest.orderId)


      if (order.isEmpty) {
        return Future.failed(
          Status
            .NOT_FOUND
            .augmentDescription("orderId not found")
            .asRuntimeException
        )
      }

      if (!(order.get.orderStatus.isopen || order.get.orderStatus.isreceived)) {
        return Future.failed(
          Status
            .UNAVAILABLE
            .augmentDescription("can only cancel orders with status open or received")
            .asRuntimeException
        )
      }

      order match {
        case order: LimitOrderEvent => {
          val cancellation = OrderUtils.cancellationFromOrder(order)

          placedCancellations(Exchange.simulationMetadata.get.currentTimeInterval) += cancellation

          Future.successful(cancellation)
        }
        case _ => Future.failed(
          Status
            .UNAVAILABLE
            .augmentDescription("can only cancel limit orders")
            .asRuntimeException
        )
        }
    }

    override def placeBuyMarketOrder(
      buyMarketOrderRequest: BuyMarketOrderRequest
    ): Future[BuyMarketOrder] = {
      val orderRequestId = storeOrderRequest(buyMarketOrderRequest)

      val buyMarketOrder = BuyMarketOrder(
        buyMarketOrderRequest.funds,
        OrderUtils.generateOrderId,
        OrderStatus.received,
        buyMarketOrderRequest.productId,
        OrderSide.buy,
        Exchange.simulationMetadata.get.currentTimeInterval.endTime,
        RejectReason.notRejected,
        orderRequestId
      )

      val rejectReason = OrderRejecter.isBuyMarketOrderInvalid(buyMarketOrder)
      if (rejectReason.isDefined) {
        buyMarketOrder.update(_.rejectReason := rejectReason.get)
      } else {
        Wallets.incrementHolds(buyMarketOrder)
      }
      placedOrders.update(buyMarketOrder.orderId, buyMarketOrder)

      Future.successful(buyMarketOrder)
    }

    override def placeBuyLimitOrder(
      buylimitOrderRequest: BuyLimitOrderRequest
    ): Future[BuyLimitOrder] = {
      val orderRequestId = storeOrderRequest(buylimitOrderRequest)

      val limitOrder = new BuyLimitOrder(
        OrderUtils.generateOrderId,
        OrderStatus.received,
        buylimitOrderRequest.price,
        buylimitOrderRequest.productId,
        OrderSide.buy,
        buylimitOrderRequest.size,
        Exchange.simulationMetadata.get.currentTimeInterval.endTime,
        RejectReason.notRejected,
        orderRequestId
      )

      val rejectReason = OrderRejecter.isLimitOrderInvalid(limitOrder)
      if (rejectReason.isDefined) {
        limitOrder.update(_.rejectReason := rejectReason.get)
      } else {
        Wallets.incrementHolds(limitOrder)
      }
      placedOrders.update(limitOrder.orderId, limitOrder)

      Future.successful(limitOrder)
    }

    override def placeSellLimitOrder(
      sellLimitOrderRequest: SellLimitOrderRequest
    ): Future[SellLimitOrder] = {
      val orderRequestId = storeOrderRequest(sellLimitOrderRequest)

      val sellLimitOrder = new SellLimitOrder(
        OrderUtils.generateOrderId,
        OrderStatus.received,
        sellLimitOrderRequest.price,
        sellLimitOrderRequest.productId,
        OrderSide.sell,
        sellLimitOrderRequest.size,
        Exchange.simulationMetadata.get.currentTimeInterval.endTime,
        RejectReason.notRejected,
        orderRequestId
      )

      val rejectReason = OrderRejecter.isLimitOrderInvalid(sellLimitOrder)
      if (rejectReason.isDefined) {
        sellLimitOrder.update(_.rejectReason := rejectReason.get)
      } else {
        Wallets.incrementHolds(sellLimitOrder)
      }
      placedOrders.update(sellLimitOrder.orderId, sellLimitOrder)

      Future.successful(sellLimitOrder)
    }

    override def placeSellMarketOrder(
      sellMarketOrderRequest: SellMarketOrderRequest
    ): Future[SellMarketOrder] = {
      val orderRequestId = storeOrderRequest(sellMarketOrderRequest)

      val sellMarketOrder = SellMarketOrder(
        OrderUtils.generateOrderId,
        OrderStatus.received,
        sellMarketOrderRequest.productId,
        OrderSide.sell,
        sellMarketOrderRequest.size,
        Exchange.simulationMetadata.get.currentTimeInterval.endTime,
        RejectReason.notRejected,
        orderRequestId
      )

      val rejectReason = OrderRejecter.isSellMarketOrderInvalid(sellMarketOrder)
      if (rejectReason.isDefined) {
        sellMarketOrder.update(_.rejectReason := rejectReason.get)
      } else {
        Wallets.incrementHolds(sellMarketOrder)
      }

      placedOrders.update(sellMarketOrder.orderId, sellMarketOrder)

      Future.successful(sellMarketOrder)
    }

    private def storeOrderRequest(orderRequest: OrderRequest): OrderRequestId = {
      val orderRequestId = OrderRequestId(UUID.randomUUID().toString)
      orderRequests.update(orderRequestId, orderRequest)
      orderRequestId
    }
  }

  object OrderRejecter {
    def isBuyMarketOrderInvalid(
      buyMarketOrder: BuyMarketOrder
    ): Option[RejectReason] = {
      List(isFundsInvalid _, hasInsufficientFunds _).view
        .flatMap(f => f(buyMarketOrder))
        .headOption
    }

    private def isFundsInvalid(
      buyMarketOrder: BuyMarketOrder
    ): Option[RejectReason] = {
      buyMarketOrder.funds match {
        case funds if funds > QuoteVolume.maxVolume =>
          Some(RejectReason.fundsTooLarge)
        case funds if funds < QuoteVolume.minVolume =>
          Some(RejectReason.fundsTooSmall)
        case _ => None
      }
    }

    def isLimitOrderInvalid(limitOrder: LimitOrderEvent): Option[RejectReason] = {
      List(
        isPriceInvalid _,
        isSizeInvalid _,
        violatesPostOnly _,
        hasInsufficientFunds _
      ).view
        .flatMap(f => f(limitOrder))
        .headOption
    }

    private def hasInsufficientFunds(order: OrderEvent): Option[RejectReason] = {
      order match {
        case order: BuyOrderEvent => {
          if (Account.hasSufficientFunds(order)) None
          else Some(RejectReason.insufficientFunds)
        }
        case order: SellOrderEvent => {
          if (Account.hasSufficientSize(order)) None
          else Some(RejectReason.insufficientFunds)
        }
      }
    }

    private def isPriceInvalid(limitOrder: LimitOrderEvent): Option[RejectReason] = {
      limitOrder.price match {
        case price if price > ProductPrice.maxPrice =>
          Some(RejectReason.priceTooLarge)
        case price if price < ProductPrice.minPrice =>
          Some(RejectReason.priceTooSmall)
        case _ => None
      }
    }

    private def isSizeInvalid(order: SpecifiesSize): Option[RejectReason] = {
      order.size match {
        case size if size > ProductVolume.maxVolume =>
          Some(RejectReason.sizeTooLarge)
        case size if size < ProductVolume.minVolume =>
          Some(RejectReason.sizeTooSmall)
        case _ => None
      }
    }

    private def violatesPostOnly(
      limitOrder: LimitOrderEvent
    ): Option[RejectReason] = {
      val orderRequest = Account.getOrderRequest[LimitOrderRequst](limitOrder.requestId)
      val violatesPostOnly = Exchange.checkIsTaker(limitOrder) && orderRequest.get.postOnly
      if (violatesPostOnly) Some(RejectReason.postOnly) else None
    }

    def isSellMarketOrderInvalid(
      sellMarketOrder: SellMarketOrder
    ): Option[RejectReason] = {
      List(isSizeInvalid _, hasInsufficientFunds _).view
        .flatMap(f => f(sellMarketOrder))
        .headOption
    }
  }
}
