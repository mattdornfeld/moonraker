package co.firstorderlabs.fakebase

import java.math.BigDecimal
import java.util.UUID

import co.firstorderlabs.fakebase.Wallets.WalletMap
import co.firstorderlabs.fakebase.currency.Configs.ProductPrice
import co.firstorderlabs.fakebase.currency.Configs.ProductPrice.{
  ProductVolume,
  QuoteVolume
}
import co.firstorderlabs.fakebase.currency.Volume.{Volume, VolumeCompanion}
import co.firstorderlabs.fakebase.protos.fakebase.{
  AccountServiceGrpc,
  BuyLimitOrder,
  BuyLimitOrderRequest,
  BuyMarketOrder,
  BuyMarketOrderRequest,
  Cancellation,
  CancellationRequest,
  DoneReason,
  Liquidity,
  Match,
  MatchEvents,
  Order,
  OrderSide,
  OrderStatus,
  Orders,
  RejectReason,
  SellLimitOrder,
  SellLimitOrderRequest,
  SellMarketOrder,
  SellMarketOrderRequest,
  Wallet => WalletProto,
  Wallets => WalletsProto
}
import co.firstorderlabs.fakebase.types.Events._
import co.firstorderlabs.fakebase.types.Types.{
  Currency,
  OrderId,
  OrderRequestId,
  TimeInterval
}
import com.google.protobuf.empty.Empty
import io.grpc.Status

import scala.collection.mutable.{HashMap, ListBuffer}
import scala.concurrent.Future

case class Wallet[A <: Volume[A]](currency: Currency,
                                  initialBalance: A,
                                  walletId: String) {
  var balance = initialBalance
  var holds = initialBalance.companion.zeroVolume

  def setHolds(volume: A): Unit = {
    holds = volume
  }

  def toProto: WalletProto =
    WalletProto(walletId, balance.toPlainString, holds.toPlainString)

  override def toString: String = {
    s"Wallet(${currency}, ${balance}, ${holds}, ${walletId})"
  }

}

case class WalletsCheckpoint(walletsMap: WalletMap) extends Checkpoint

object Wallets extends Checkpointable[WalletsCheckpoint] {
  // This type was autogenerated by intellij. I don't fully understand it, but it works.
  type WalletMap =
    HashMap[Currency, Wallet[_ >: ProductVolume with QuoteVolume <: Volume[
      _ >: ProductVolume with QuoteVolume
    ]]]

  private val walletsMap: WalletMap = new HashMap

  def addFunds[A <: Volume[A]](volume: A): Unit = {
    getWallet(volume.companion).balance += volume
  }

  def calcRequiredBuyHold(order: BuyOrderEvent): QuoteVolume = {
    order match {
      case order: BuyLimitOrder => {
        val feeFraction =
          if (Exchange.checkIsTaker(order))
            Configs.feeFraction(Liquidity.taker)
          else Configs.feeFraction(Liquidity.maker)
        order.price * order.size * Left(feeFraction.add(new BigDecimal("1.0")))
      }
      case order: BuyMarketOrder => {
        val feeFraction = Configs.feeFraction(Liquidity.taker)
        order.funds * Left(feeFraction.add(new BigDecimal("1.0")))
      }
    }
  }

  def checkpoint: WalletsCheckpoint = WalletsCheckpoint(walletsMap.clone)

  def clear: Unit = walletsMap.clear

  def getAvailableFunds[A <: Volume[A]](
    volume: VolumeCompanion[A]
  ): Volume[A] = {
    val wallet = getWallet(volume)
    wallet.balance - wallet.holds
  }

  def incrementHolds(order: OrderEvent): Unit = {
    order match {
      case order: BuyOrderEvent => {
        val wallet = getWallet(QuoteVolume)
        val orderHolds = Wallets.calcRequiredBuyHold(order)
        val newHolds = wallet.holds + orderHolds
        wallet.setHolds(newHolds)
        order.holds = orderHolds
      }
      case order: SellOrderEvent => {
        val wallet = getWallet(ProductVolume)
        val newHolds = wallet.holds + order.size
        wallet.setHolds(newHolds)
        order.holds = order.size
      }
    }
  }

  def initializeWallets: Unit = {
    walletsMap(ProductVolume.currency) = Wallet(
      ProductVolume.currency,
      new ProductVolume(Right("0.0")),
      UUID.randomUUID().toString
    )
    walletsMap(QuoteVolume.currency) = Wallet(
      QuoteVolume.currency,
      new QuoteVolume(Right("0.0")),
      UUID.randomUUID().toString
    )
  }

  def updateBalances(matchEvent: MatchEvent): Unit = {
    val productWallet = getWallet(ProductVolume)
    val quoteWallet = getWallet(QuoteVolume)
    matchEvent.getAccountOrder.get match {
      case order: BuyOrderEvent => {
        productWallet.balance = productWallet.balance + matchEvent.size
        val balanceDelta = matchEvent.quoteVolume + matchEvent.fee
        quoteWallet.balance = quoteWallet.balance - balanceDelta
        quoteWallet.holds = quoteWallet.holds - balanceDelta
        order.holds = order.holds - balanceDelta
      }
      case order: SellOrderEvent => {
        productWallet.balance = productWallet.balance - matchEvent.size
        productWallet.holds = productWallet.holds - matchEvent.size
        order.holds = order.holds - matchEvent.size
        quoteWallet.balance = quoteWallet.balance + matchEvent.quoteVolume - matchEvent.fee
      }
    }
  }

  def getWallet[A <: Volume[A]](volume: VolumeCompanion[A]): Wallet[A] = {
    walletsMap(volume.currency).asInstanceOf[Wallet[A]]
  }

  def removeHolds(order: OrderEvent) = {
    order match {
      case order: BuyOrderEvent => {
        val wallet = getWallet(QuoteVolume)
        val newHolds = wallet.holds - order.holds
        wallet.setHolds(newHolds)
        order.holds = QuoteVolume.zeroVolume
      }
      case order: SellOrderEvent => {
        val wallet = getWallet(ProductVolume)
        val newHolds = wallet.holds - order.holds
        wallet.setHolds(newHolds)
        order.holds = ProductVolume.zeroVolume
      }
    }
  }

  def restore(checkpoint: WalletsCheckpoint): Unit = {
    clear
    walletsMap.addAll(checkpoint.walletsMap.iterator)
  }

  def toProto: WalletsProto =
    WalletsProto(
      Map(
        ProductVolume.currency.currency -> getWallet(ProductVolume).toProto,
        QuoteVolume.currency.currency -> getWallet(QuoteVolume).toProto
      )
    )
}

class CancellationsHashMap
    extends HashMap[TimeInterval, ListBuffer[Cancellation]] {
  override def clone: CancellationsHashMap = {
    val clonedMap = new CancellationsHashMap
    clonedMap.addAll(super.clone.iterator)
  }

  override def apply(key: TimeInterval): ListBuffer[Cancellation] =
    super.getOrElseUpdate(key, ListBuffer())
}

class MatchesHashMap extends HashMap[OrderId, ListBuffer[Match]] {
  override def clone: MatchesHashMap = {
    val clonedMap = new MatchesHashMap
    clonedMap.addAll(super.clone.iterator)
  }

  override def apply(key: OrderId): ListBuffer[Match] =
    super.getOrElseUpdate(key, ListBuffer())

}

case class AccountCheckpoint(
  orderRequests: HashMap[OrderRequestId, OrderRequest],
  placedCancellations: CancellationsHashMap,
  placedOrders: HashMap[OrderId, OrderEvent],
  matches: MatchesHashMap,
  walletsCheckpoint: WalletsCheckpoint,
  matchesInCurrentTimeInterval: ListBuffer[Match]
) extends Checkpoint

object Account
    extends AccountServiceGrpc.AccountService
    with Checkpointable[AccountCheckpoint] {
  val matches = new MatchesHashMap
  val placedOrders = new HashMap[OrderId, OrderEvent]
  private val orderRequests = new HashMap[OrderRequestId, OrderRequest]
  private val placedCancellations = new CancellationsHashMap
  private val matchesInCurrentTimeInterval = new ListBuffer[Match]

  def addFunds[A <: Volume[A]](volume: A): Unit = {
    Wallets.addFunds(volume)
  }

  def addMatch(matchEvent: Match): Unit = {
    matchesInCurrentTimeInterval append matchEvent
    val orderId = matchEvent.getAccountOrder.get.orderId
    matches(orderId) append matchEvent
  }

  def belongsToAccount(order: OrderEvent): Boolean = {
    placedOrders.contains(order.orderId)
  }

  def checkpoint: AccountCheckpoint =
    AccountCheckpoint(
      orderRequests.clone,
      placedCancellations.clone,
      placedOrders.clone,
      matches.clone,
      Wallets.checkpoint,
      matchesInCurrentTimeInterval.clone
    )

  def clear: Unit = {
    orderRequests.clear
    placedCancellations.clear
    placedOrders.clear
    matches.clear
    Wallets.clear
    matchesInCurrentTimeInterval.clear
  }

  def closeOrder[A <: OrderEvent](order: A,
                                  doneReason: DoneReason): Option[A] = {
    if (placedOrders.contains(order.orderId))
      if (!List(OrderStatus.received, OrderStatus.open).contains(
            order.orderStatus
          )) return None

    Wallets.removeHolds(order)

    val updatedOrder = OrderUtils.setOrderStatusToDone(order, doneReason)
    placedOrders.update(updatedOrder.orderId, updatedOrder)
    Some(updatedOrder)
  }

  def openOrder(orderId: OrderId): Option[LimitOrderEvent] = {
    val order = placedOrders.get(orderId)
    order match {
      case Some(order) => {
        order match {
          case order: LimitOrderEvent => {
            val updatedOrder = OrderUtils.openOrder(order)
            placedOrders.update(orderId, updatedOrder)
            Some(updatedOrder)
          }
          case _ => None
        }
      }
      case None => None
    }
  }

  def getOrderRequest[A <: OrderRequest](
    orderRequestId: OrderRequestId
  ): Option[A] = {
    if (orderRequests.contains(orderRequestId))
      Some(orderRequests.get(orderRequestId).get.asInstanceOf[A])
    else
      None
  }

  def getReceivedCancellations: Iterable[Cancellation] = {
    val timeInterval = Exchange.simulationMetadata.get.currentTimeInterval - Exchange.simulationMetadata.get.timeDelta
    for (cancellation <- placedCancellations(timeInterval))
      yield cancellation
  }

  def getReceivedOrders: Iterable[OrderEvent] = {
    for (order <- placedOrders.values
         if order.orderStatus == OrderStatus.received)
      yield order
  }

  def hasSufficientFunds(order: BuyOrderEvent): Boolean = {
    val requiredBuyHold = Wallets.calcRequiredBuyHold(order)
    requiredBuyHold > Wallets.getAvailableFunds(QuoteVolume)
  }

  def hasSufficientSize(order: SpecifiesSize): Boolean = {
    val productFunds = Wallets.getAvailableFunds(ProductVolume)
    order.size > productFunds
  }

  def initializeWallets: Unit = Wallets.initializeWallets

  def restore(checkpoint: AccountCheckpoint): Unit = {
    clear
    orderRequests.addAll(checkpoint.orderRequests.iterator)
    placedCancellations.addAll(checkpoint.placedCancellations.iterator)
    placedOrders.addAll(checkpoint.placedOrders.iterator)
    matches.addAll(checkpoint.matches.iterator)
    Wallets.restore(checkpoint.walletsCheckpoint)
    matchesInCurrentTimeInterval.addAll(checkpoint.matchesInCurrentTimeInterval)
  }

  def step: Unit = {
    matchesInCurrentTimeInterval.clear
  }

  def updateBalance(matchEvent: MatchEvent): Unit = {
    Wallets.updateBalances(matchEvent)
  }

  override def cancelOrder(
    cancellationRequest: CancellationRequest
  ): Future[Cancellation] = {
    val order = placedOrders.get(cancellationRequest.orderId)

    if (order.isEmpty) {
      return Future.failed(
        Status.NOT_FOUND
          .augmentDescription("orderId not found")
          .asRuntimeException
      )
    }

    if (!(order.get.orderStatus.isopen || order.get.orderStatus.isreceived)) {
      return Future.failed(
        Status.UNAVAILABLE
          .augmentDescription(
            "can only cancel orders with status open or received"
          )
          .asRuntimeException
      )
    }

    order.get match {
      case order: LimitOrderEvent => {
        val cancellation = OrderUtils.cancellationFromOrder(order)

        placedCancellations(Exchange.simulationMetadata.get.currentTimeInterval) += cancellation

        Future.successful(cancellation)
      }
      case _ => {
        Future.failed(
          Status.UNAVAILABLE
            .augmentDescription("can only cancel limit orders")
            .asRuntimeException
        )
      }
    }
  }

  override def getMatches(request: Empty): Future[MatchEvents] = {
    val matchEvents = MatchEvents(matchesInCurrentTimeInterval.toSeq)
    Future.successful(matchEvents)
  }

  override def getOrders(request: Empty): Future[Orders] = {
    val orders = Orders(
      placedOrders
        .map(
          item =>
            (
              item._1,
              OrderUtils
                .addMatchesToOrder(item._2, matches(item._2.orderId).toSeq)
          )
        )
        .map(
          item => (item._1.orderId, OrderUtils.orderEventToSealedOneOf(item._2))
        )
        .toMap[String, Order]
    )

    Future.successful(orders)
  }

  override def getWallets(request: Empty): Future[WalletsProto] =
    Future.successful(Wallets.toProto)

  override def placeBuyMarketOrder(
    buyMarketOrderRequest: BuyMarketOrderRequest
  ): Future[BuyMarketOrder] = {
    val orderRequestId = storeOrderRequest(buyMarketOrderRequest)

    val buyMarketOrder = BuyMarketOrder(
      funds = buyMarketOrderRequest.funds,
      orderId = OrderUtils.generateOrderId,
      orderStatus = OrderStatus.received,
      productId = buyMarketOrderRequest.productId,
      side = OrderSide.buy,
      time = Exchange.simulationMetadata.get.currentTimeInterval.endTime,
      rejectReason = RejectReason.notRejected,
      requestId = orderRequestId,
      matchEvents = Some(MatchEvents())
    )

    Future.successful(processOrder(buyMarketOrder))
  }

  override def placeBuyLimitOrder(
    buyLimitOrderRequest: BuyLimitOrderRequest
  ): Future[BuyLimitOrder] = {
    val orderRequestId = storeOrderRequest(buyLimitOrderRequest)

    val buyLimitOrder = new BuyLimitOrder(
      orderId = OrderUtils.generateOrderId,
      orderStatus = OrderStatus.received,
      price = buyLimitOrderRequest.price,
      productId = buyLimitOrderRequest.productId,
      side = OrderSide.buy,
      size = buyLimitOrderRequest.size,
      time = Exchange.simulationMetadata.get.currentTimeInterval.endTime,
      rejectReason = RejectReason.notRejected,
      requestId = orderRequestId,
      matchEvents = Some(MatchEvents())
    )

    Future.successful(processOrder(buyLimitOrder))
  }

  override def placeSellLimitOrder(
    sellLimitOrderRequest: SellLimitOrderRequest
  ): Future[SellLimitOrder] = {
    val orderRequestId = storeOrderRequest(sellLimitOrderRequest)

    val sellLimitOrder = new SellLimitOrder(
      orderId = OrderUtils.generateOrderId,
      orderStatus = OrderStatus.received,
      price = sellLimitOrderRequest.price,
      productId = sellLimitOrderRequest.productId,
      side = OrderSide.sell,
      size = sellLimitOrderRequest.size,
      time = Exchange.simulationMetadata.get.currentTimeInterval.endTime,
      rejectReason = RejectReason.notRejected,
      requestId = orderRequestId,
      matchEvents = Some(MatchEvents())
    )

    Future.successful(processOrder(sellLimitOrder))
  }

  override def placeSellMarketOrder(
    sellMarketOrderRequest: SellMarketOrderRequest
  ): Future[SellMarketOrder] = {
    val orderRequestId = storeOrderRequest(sellMarketOrderRequest)

    val sellMarketOrder = SellMarketOrder(
      orderId = OrderUtils.generateOrderId,
      orderStatus = OrderStatus.received,
      productId = sellMarketOrderRequest.productId,
      side = OrderSide.sell,
      size = sellMarketOrderRequest.size,
      time = Exchange.simulationMetadata.get.currentTimeInterval.endTime,
      rejectReason = RejectReason.notRejected,
      requestId = orderRequestId,
      matchEvents = Some(MatchEvents())
    )

    Future.successful(processOrder(sellMarketOrder))
  }

  private def processOrder[A <: OrderEvent](order: A): A = {
    val rejectReason = OrderRejecter.getRejectReason(order)
    if (rejectReason.isDefined) {
      val rejectedOrder = OrderUtils.rejectOrder(order, rejectReason.get)
      placedOrders.update(rejectedOrder.orderId, rejectedOrder)
      rejectedOrder
    } else {
      Wallets.incrementHolds(order)
      placedOrders.update(order.orderId, order)
      order
    }
  }

  private def storeOrderRequest(orderRequest: OrderRequest): OrderRequestId = {
    val orderRequestId = OrderRequestId(UUID.randomUUID().toString)
    orderRequests.update(orderRequestId, orderRequest)
    orderRequestId
  }
}

object OrderRejecter {
  def isBuyMarketOrderInvalid(
    buyMarketOrder: BuyMarketOrder
  ): Option[RejectReason] = {
    List(isFundsInvalid _, hasInsufficientFunds _).view
      .flatMap(f => f(buyMarketOrder))
      .headOption
  }

  private def isFundsInvalid(
    buyMarketOrder: BuyMarketOrder
  ): Option[RejectReason] = {
    buyMarketOrder.funds match {
      case funds if funds > QuoteVolume.maxVolume =>
        Some(RejectReason.fundsTooLarge)
      case funds if funds < QuoteVolume.minVolume =>
        Some(RejectReason.fundsTooSmall)
      case _ => None
    }
  }

  def isLimitOrderInvalid(limitOrder: LimitOrderEvent): Option[RejectReason] = {
    List(
      isPriceInvalid _,
      isSizeInvalid _,
      violatesPostOnly _,
      hasInsufficientFunds _
    ).view
      .flatMap(f => f(limitOrder))
      .headOption
  }

  def getRejectReason[A <: OrderEvent](order: A): Option[RejectReason] = {
    order match {
      case order: LimitOrderEvent => OrderRejecter.isLimitOrderInvalid(order)
      case order: BuyMarketOrder =>
        OrderRejecter.isBuyMarketOrderInvalid(order)
      case order: SellMarketOrder =>
        OrderRejecter.isSellMarketOrderInvalid(order)
    }
  }

  private def hasInsufficientFunds(order: OrderEvent): Option[RejectReason] = {
    order match {
      case order: BuyOrderEvent => {
        if (Account.hasSufficientFunds(order))
          Some(RejectReason.insufficientFunds)
        else None
      }
      case order: SellOrderEvent => {
        if (Account.hasSufficientSize(order))
          Some(RejectReason.insufficientFunds)
        else None
      }
    }
  }

  private def isPriceInvalid(
    limitOrder: LimitOrderEvent
  ): Option[RejectReason] = {
    limitOrder.price match {
      case price if price > ProductPrice.maxPrice =>
        Some(RejectReason.priceTooLarge)
      case price if price < ProductPrice.minPrice =>
        Some(RejectReason.priceTooSmall)
      case _ => None
    }
  }

  private def isSizeInvalid(order: SpecifiesSize): Option[RejectReason] = {
    order.size match {
      case size if size > ProductVolume.maxVolume =>
        Some(RejectReason.sizeTooLarge)
      case size if size < ProductVolume.minVolume =>
        Some(RejectReason.sizeTooSmall)
      case _ => None
    }
  }

  private def violatesPostOnly(
    limitOrder: LimitOrderEvent
  ): Option[RejectReason] = {
    val orderRequest =
      Account.getOrderRequest[LimitOrderRequest](limitOrder.requestId)
    val violatesPostOnly = Exchange.checkIsTaker(limitOrder) && orderRequest.get.postOnly
    if (violatesPostOnly) Some(RejectReason.postOnly) else None
  }

  def isSellMarketOrderInvalid(
    sellMarketOrder: SellMarketOrder
  ): Option[RejectReason] = {
    List(isSizeInvalid _, hasInsufficientFunds _).view
      .flatMap(f => f(sellMarketOrder))
      .headOption
  }
}
